#########################
C++ Interview Questions
#########################

FAQ
=======================================================
1. 请详细阐述 C++ 中右值引用的原理、用途以及它是如何优化程序性能的 (结合移动语义与完美转发概念) ?

* 原理:

右值引用通过&&声明, 绑定到即将销毁的临时对象 (右值) , 与左值引用 (&) 区分开, 左值引用通常绑定到具名变量等持久存在的左值。
例如int&& r = 5 + 3;, 这里5 + 3是右值, 被r绑定。

* 用途与性能优化:

移动语义方面, 对于像自定义类中管理动态内存资源的情况, 传统拷贝构造函数和赋值运算符会深拷贝资源, 效率低。而移动构造函数 (接受右值引用参数) 能“窃取”源对象即将销毁的资源, 避免不必要拷贝。

如std::vector扩容时, 旧数据可通过移动而非拷贝到新内存空间。完美转发利用std::forward函数, 在模板函数中, 按照传入参数的原有值类别 (左值或右值) 准确传递给被调用函数, 保持调用语义, 避免额外拷贝开销, 高效传递参数, 典型在工厂函数、代理函数场景提升性能。

2. 深度剖析 C++ 标准库中智能指针的实现机制、内存管理细节、循环引用问题及weak_ptr如何解决该问题?

* unique_ptr实现独占式资源管理, 内部有个指针指向对象, 析构时自动释放内存, 禁止拷贝构造与赋值 (除非特殊转移语义的move操作) , 确保单一所有权, 内存管理简单直接, 生命周期跟随其作用域, 出作用域自动析构。

* shared_ptr基于引用计数实现共享式所有权, 有个内部计数器记录指向同一对象的shared_ptr个数, 构造、拷贝、赋值时更新计数, 计数归零才析构对象释放内存。但循环引用场景下, 如两个类相互包含shared_ptr成员, 析构顺序会陷入僵局导致内存泄漏。

* weak_ptr不控制对象生命周期, 只观测对象是否存活, 通过指向shared_ptr管理的对象, 避免循环引用。它构造时关联shared_ptr, 获取资源需先lock转换为shared_ptr (若对象已析构返回空shared_ptr) , 打破循环强引用闭环, 解决循环引用导致的内存无法释放问题。

3. 在多线程环境下使用 C++, 阐述如何利用std::atomic、互斥锁 (std::mutex等) 、条件变量 (std::condition_variable)来安全高效地实现一个生产者 - 消费者模型, 详细分析各组件作用及可能遇到的同步、并发问题?

* std::atomic用于对简单数据类型 (如int、bool等) 原子操作, 保证读写不可分割, 像共享计数器, 避免多线程下数据竞争导致不一致, 无锁操作性能高, 但操作受限

* std::mutex提供互斥访问, 生产者线程获取锁往队列添加数据, 消费者获取锁从队列取数据, 防止同时读写共享队列造成混乱, 但频繁加解锁有性能开销, 若锁粒度大还会阻塞并发。

* std::condition_variable配合std::unique_lock std::mutex使用, 生产者添加数据后通知等待的消费者, 消费者队列为空时等待信号, 避免忙等浪费 CPU 资源, 协调生产者消费者步调。可能问题有虚假唤醒 (需二次检查条件) 、锁争用导致性能瓶颈、队列容量限制引发生产者阻塞等, 要合理设计队列大小、优化锁策略应对。

4. 解释 C++ 模板元编程的概念、原理, 举例说明如何利用模板元编程实现编译期计算 (如斐波那契数列计算、类型萃取等) , 分析其优缺点?

* 概念与原理:

模板元编程是在编译期基于 C++ 模板机制进行编程, 将计算从运行时提前到编译时。编译器在实例化模板时展开推导代码逻辑, 把模板参数当常量处理。

* 实例:

计算斐波那契数列, 利用模板递归与特化, 像template<int N> struct Fibonacci { static constexpr int value = Fibonacci<N - 1>::value + Fibonacci<N - 2>::value; };, 特化Fibonacci<0>和Fibonacci<1>终止递归, 编译期算出值。类型萃取可定义template<typename T> struct TypeTrait检查类型是否是const、指针等属性, 借助typedef、std::enable_if等工具。

* 优点是运行时无计算开销、可优化代码结构、能做静态检查；缺点是编译时间长、编译器报错复杂难懂、代码可读性差、调试困难, 因逻辑在编译阶段展开, 不易追踪问题。

5. 深入分析 C++ 中虚函数表 (vtable) 和虚函数指针 (vptr) 如何影响对象的内存占用与函数调用效率?

它的底层内存布局、工作机制, 在多重继承下其布局与单继承有何不同?

* 内存布局与机制:

类含虚函数时, 编译器生成虚函数表, 存虚函数地址, 类对象内存起始处有虚函数指针指向对应 vtable。
调用虚函数时, 通过对象 vptr 找 vtable, 再按偏移取目标虚函数地址调用, 实现运行时多态。

* 单继承下, 派生类对象内存先布局基类部分 (含 vptr) 再是派生类独有数据, vptr 指向派生类专属 vtable (含重写及新增虚函数地址) , 函数调用按 vptr - vtable 流程高效查找。

多重继承复杂些, 每个父类有独立 vtable 和 vptr, 派生类对象含多个 vptr, 内存按继承顺序依次排列各基类部分, 函数调用依对象指针类型、所指基类区域找对应 vptr 与 vtable, 内存占用多且因间接层次多, 调用效率略降, 有额外偏移计算。

6. 剖析 C++ 异常处理机制 (try - catch - throw) 的底层实现原理、栈展开过程, 对程序性能的影响以及如何合理设计异常安全的代码结构(如 RAII 与异常处理结合)?

* 底层实现:

编译器在编译try块代码时, 插入特殊代码记录栈帧状态, throw执行时逆栈查找匹配catch块, 清理沿途自动对象 (调用析构函数) , 调整栈指针与程序流程。

* 栈展开:

从throw点开始, 沿调用栈回溯, 依次析构局部对象, 直至找到匹配catch, 若没匹配且没std::terminate处理则程序异常终止。

* 性能影响:

引入额外代码生成、运行时栈操作开销, 频繁异常抛出会降性能。
合理设计上, 利用 RAII (资源获取即初始化) , 类构造时获取资源, 析构自动释放, 如智能指针管理内存、文件流类管理文件, 确保异常下资源正常释放, 代码块遵循“要么全成功要么无影响”原子性, 避免部分成功部分失败导致数据不一致。

7. 在 C++ 中, 给定一个复杂类层次结构 (包含多层继承、多重继承、虚基类等) , 详细说明对象的内存布局是如何确定的, 构造函数与析构函数的调用顺序遵循怎样的规则, 为何这样设计?


* 内存布局: 单继承下, 派生类内存先排基类成员再是自身, 按声明顺序；多重继承依次排各基类部分 (重复基类按虚基类规则优化) , 同样成员按声明。虚基类特殊, 为避免多重副本, 在派生类内存只有一份, 位置由编译器定 (常居末尾) , 各路径访问通过偏移调整。

* 构造函数顺序: 按继承层次, 先虚基类 (按继承树从根到叶顺序) , 再非虚基类 (从左到右继承顺序) , 最后派生类自身, 保证基类完整初始化供派生类使用。

* 析构函数相反, 先派生类自身清理, 再按构造逆序析构基类, 确保对象层次结构有序销毁, 释放资源, 维持内存安全、避免悬空指针等问题, 依依赖层次设计调用顺序保障完整性与正确性。

8. 阐述 C++ 中constexpr关键字的作用、适用场景、与常量表达式的关系, 如何利用它在编译期进行复杂逻辑 (如数组大小动态计算、编译期字符串处理等) 的优化?

* 作用:

修饰变量、函数、对象构造等, 告知编译器在编译期求值生成常量, 变量具constexpr属性则是编译期常量, 函数则可在编译期调用计算。

* 适用场景:

定义数组大小 (constexpr int size = 10; int arr[size];) 、初始化常量数据结构 (如编译期构建std::array) 等。与常量表达式关系紧密, constexpr声明旨在参与常量表达式求值, 确保编译期确定值。

* 复杂逻辑优化:

编译期字符串处理可定义constexpr函数拼接、截取字符串常量 (借助模板递归、字符数组操作) , 数组动态计算按运行时输入用constexpr函数算合法大小, 生成对应大小数组, 减少运行时动态内存分配与计算开销, 提升性能、利用编译期算力。

9. 分析 C++ 标准库中容器 (如std::vector、std::map、std::unordered_map) 的底层数据结构、内存管理策略、扩容机制以及在不同使用场景 (查找频繁、插入频繁、遍历频繁等) 下如何选择最合适的容器, 理由是什么?

* std::vector底层是动态数组, 内存连续, 有容量和大小概念, 扩容常按倍数 (如 2 倍) 申请新内存、拷贝旧数据再析构旧空间, 随机访问快 (O(1)) , 尾部插入删除O(1), 中间操作需移动元素O(n), 适合遍历频繁、尾部操作场景。

* std::map基于红黑树实现, 键值对有序存储, 平衡树特性保证插入、删除、查找O(log n), 内存按需节点分配, 自动平衡树结构, 适合按序遍历、频繁查找修改场景, 有序性方便范围查询。

* std::unordered_map用哈希表, 内部有桶数组与哈希函数, 键经哈希映射到桶, 平均查找、插入、删除O(1), 但最坏O(n) (哈希冲突严重) , 扩容重哈希分配桶, 适合大量随机查找、不关心顺序且对平均性能有要求场景, 不同场景依操作复杂度、数据特性、顺序需求选容器优化效率。

10. 当在 C++ 项目中集成第三方库 (如Boost部分组件、OpenCV等) , 面临版本兼容性、命名空间冲突、内存管理差异等问题, 详细阐述应对策略与实际操作方法, 如何保证项目整体稳定性与可维护性?

* 版本兼容性: 调研库版本发布说明、变更日志, 锁定稳定兼容版, 用包管理工具 (vcpkg、conan等) 规范依赖版本, 定期更新重测, 对重大版本变更评估适配成本, 必要时保留旧版分支过渡。
* 命名空间冲突: 第三方库常用全局命名空间或特定前缀, 通过using声明局部导入所需部分 (避免头文件全局using) , 或全限定名访问 (boost::asio::xxx) , 必要时封装库接口, 隔离命名空间影响。
* 内存管理差异: 若库与项目内存管理习惯不同 (像手动new/delete与智能指针混用) , 在外层封装适配层, 统一接口管理资源, 如用智能指针接管第三方库返回裸指针, 确保释放一致, 加强代码审查、单元测试, 监控内存泄漏、悬空指针等, 维护稳定可维护项目架构。



C语言
===================================================

const的作用有哪些, 谈一谈你对const的理解?

描述char*、const char*、char* const、const char* const的区别?
---------------------------------------------------------------------

    char* p0;              //指向 char 的指针
    char * const p1;       //指向 char 的 const 指针 - 指针本身不能改动
    char const * p2;       //指向 const char 的指针
    const char* p3；       //指向 const char 的指针
    const char* const p4;  //指向 const char 的 const 指针



指针常量和常量指针有什么区别?


static的作用是什么, 什么情况下用到static?

全局变量与局部变量的区别?

宏定义的作用是什么?

内存对齐的概念?

为什么会有内存对齐?

inline 内联函数的特点有哪些?它的优缺点是什么?

如何避免野指针?

如何计算结构体长度?

sizeof和strlen有什么区别?

知道条件变量吗?

条件变量为什么要和锁配合使用?

如何用C 实现 C++ 的面向对象特性 (封装、继承、多态) 

memcpy怎么实现让它效率更高?

typedef和define有什么区别?

extern有什么作用, extern C有什么作用?

C++基础知识面试题
==========================================================
C++ OOP

C语言和C++有什么区别?

struct和class有什么区别?

extern "C"的作用?

了解RAII吗?介绍一下?RAII可是C++很重要的一个特性。

函数重载和覆盖有什么区别?

谈一谈你对多态的理解, 运行时多态的实现原理是什么?

对虚函数机制的理解, 单继承、多继承、虚继承条件下虚函数表的结构

如果虚函数是有效的, 那为什么不把所有函数设为虚函数?

构造函数可以是虚函数吗?析构函数可以是虚函数吗?

基类的析构函数可以调用虚函数吗?

基类的构造函数可以调用虚函数吗?

什么场景需要用到纯虚函数?纯虚函数的作用是什么?

指针和引用有什么区别?什么情况下用指针, 什么情况下用引用?

new和malloc有什么区别?malloc的内存可以用delete释放吗?malloc出来20字节内存, 为什么free不需要传入20呢, 不会产生内存泄漏吗?

new[]和delete[]一定要配对使用吗?为什么?

类的大小怎么计算?

volatile关键字的作用

如何实现一个线程池?说一下基本思路即可！

了解各种强制类型转换的原理及使用吗?说说?


C++11新特性
=======================================

C++11新特性你都了解多少?可以介绍一下吗?
---------------------------------------------------------


了解auto和decltype吗?
---------------------------------------------------------


谈一谈你对左值和右值的了解, 了解左值引用和右值引用吗?
---------------------------------------------------------
左值具有可标识的内存地址并可以长期存在, 右值没有可识别的内存地址, 仅存储暂时的结果。
判断一个表达是否是左值就是看它是否可以长期存在, 即它是否有一个地址。

左值可以转换为右值

.. code-block::

    int a = 1, b =2;
    int c = a + b; //a, b 隐式转换为右值


右值不能转换为左值, 但是右值可以产生一个左值。

.. code-block::

    int arr[] = {1, 2}
    int *p = &arr[0];
    *(p + 1) = 10; // p+1 是右值,  *(p + 1) 是一个左值。

一般普通引用都是左值引用,  C++11 引入了右值引用, 既引用也可以是一个右值, 为一个临时表达式的别名, 用 `T&& var = expr` 来表示


.. code-block::

    int var{5}
    int& leftRef{var};
    int&& rightRef{var + 3}

右值引用主要用于 move 移动语义



了解移动语义和完美转发吗?
---------------------------------------------------------


enum 和 enum class有什么区别?了

解列表初始化吗?

对C++11的智能指针了解多少, 可以自己实现一个智能指针吗?

平时会用到function、bind、lambda吗, 都什么场景下会用到?

对C++11的mutex和RAII lock有过了解吗?

一般什么情况下会出现内存泄漏?出现内存泄漏如何调试?

unique_ptr如何转换的所有权?

谈一谈你对面向对象的理解, 什么场景下使用继承方式, 什么场景下使用组合?

STL系列
===========================================

C++直接使用数组好还是使用std::array好?

std::array是怎么实现的?

std::vector最大的特点是什么?它的内部是怎么实现的?resize和reserve的区别是什么?clear是怎么实现的?

deque的底层数据结构是什么?它的内部是怎么实现的?

map和unordered_map有什么区别?分别在什么场景下使用?

list的使用场景?std::find可以传入list对应的迭代器吗?

string的常用函数

设计模式
============================================

不强求一一列出那23种设计模式, 说出几个常见的即可。

分别写出饿汉和懒汉线程安全的单例模式

说出观察者模式类关系和优点

说出代理模式类关系和优点

说出工厂模式概念和优点

说出构造者模式概念

说出适配器模式概念


操作系统
==============================================

进程和线程的区别?

操作系统是怎么进行进程管理的?操

作系统是如何做到进程阻塞的?

进程之间的通信方式有哪些?

线程是如何实现的?

线程之间私有和共享的资源有哪些?

一般应用程序内存空间的堆和栈的区别是什么?

进程虚拟空间是怎么布局的?

虚拟内存是如何映射到物理内存的?

了解分页内存管理吗?

什么是上下文切换, 操作系统是怎么做的上下文切换?

什么是大端字节, 什么是小端字节?如何转换字节序?

产生死锁的必要条件有哪些?如何避免死锁?

信号和信号量的区别是什么?

锁的性能开销, 锁的实现原理?

编译原理
=================================================


gcc hello.c 这行命令具体的执行过程, 内部究竟做了什么?

程序一定会从main函数开始运行吗?

如何确定某个函数有被编译输出?




Reference
==================================================
* https://github.com/fightingwangzq/cpp-learning