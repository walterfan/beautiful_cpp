#######
C++
#######


.. include:: ../links.ref
.. include:: ../tags.ref
.. include:: ../abbrs.ref

============ ==========================
**Abstract** C++
**Authors**  Walter Fan
**Status**   v1
**Updated**  |date|
============ ==========================

.. |date| date::

.. contents::
   :local:


C++ 11 新特性
---------------------------

改进的对象构造
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 继承基类的构造函数
* 默认的成员值
* 委托构造函数
* overwrite 关键字
* final 关键字
* 统一的初始化 {}


其他语言增强
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 基于范围的 for 循环
* long long int 类型 (64位)
* lambda 函数
* 移动语义和右值引用
* 强类型枚举: enum 增加了类型检查
* 智能指针
* 原始字符串字面量
* 静态断言
* 可变参数模板
* 改善了右尖括号的处理

新的关键字
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* auto 自动类型推导
* constexpr: 表达式常量
* decltype: 声明类型
* nullptr: 空指针
* thread_local: 线程局部存储

对 C++ 库的增强
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* stl 容器的列表初始化
* 随机库
* 正则表达式库
* 无序容器(hash)
* 附加的算法
* 元组模板
* 其他的新类型: chrono(时间测量), ratio(有理数分数), complex(复数)


C++ 服务器端编程
---------------------------

* 事件驱动
* 多路复用
* 多线程并发


示例
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block: c++

   std::shared_ptr<Base> p = std::make_shared<Derived>();









C++ 十大面试题
--------------------------

* Reactor 模式
* Move semantic
* 菱形继承





1. C++中 指针与引用的区别
~~~~~~~~~~~~~~~~~~~~~~~~~~

数组名会自动转换为指向数组第一个元素的指针

- 指向 const 对象的指针: 不允许用指针操作来改变其所批的 const 值

.. code-block:: c++

    const double pi = 3.14;
    double * ptr = &pi; //.. error
    const doube * ptr = &pi; // correct
    *ptr = 3.14159; // error

- const 指针: 指针本身的值不能修改

.. code-block:: c++

    int errorCode = 0;
    int errorCode2 = -1;
    int * const ptrErr = &errorCode;
    ptrErr = &errorCode2; //error

2. 一个空的 C++ class ，编译器会为它默认添加哪些东西
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

默认构造函数，复制构造函数，析构函数，赋值函数以及取值函数


.. code-block:: c++

    class User
    {
    Public
        User();
        User(const User&);
        ~User();
        User& operator=(const User&)
        User* operator&();
        Const User* operator&() const;

        //c++ 11, move constructor
        User(User&& other);
        User& operator=(User&& other);


    }

explicit 构造函数是用来防止隐式转换的


3. 封装，访问控制与友元
~~~~~~~~~~~~~~~~~~~~~~~~~~

public, private, protected, friend


4. C++ 虚函数，虚继承与虚函数表
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

虚函数是通过虚函数表实现的，如果一个类含有虚函数，系统会为这个类分配一个指针成员指向一张虚函数表，表中每一项指向一个虚函数的地址，实现上就是一个函数指针的数组

在类对象的内存布局中，首先是该类的 vtbl 指针，然后者对象数据，在通过对象指针 调用一个虚函数时，编译器生成的代码将先获取对象类的 vtbl 指针，然后调用  vtbl 中对应的项，从而实现多态性


构造函数为什么不能是虚函数呢？

    首先需要了解 vptr指针和虚函数表的概念，以及这两者的关联。

    vptr指针指向虚函数表，执行虚函数的时候，会调用vptr指针指向的虚函数的地址。

    当定义一个对象的时候，首先会分配对象内存空间，然后调用构造函数来初始化对象。vptr变量是在构造函数中进行初始化的。又因为执行虚函数需要通过vptr指针来调用。如果可以定义构造函数为虚函数，那么就会陷入先有鸡还是先有蛋的循环讨论中。



基类的析构函数为什么必须是虚函数呢？

    我们都知道，想要回收一个对象申请的资源，那么就需要调用析构函数。虽然我们没有显示地调用析构函数，但是编译器都会默认地为我们执行析构函数。

    那么当我们执行 `BaseClass *base = new BaseClass();` 当我们执行 `delete base` 时，会调用析构函数为我们释放资源。而 我们执行 `BaseClass *sub = new SubClass();` 如果 `BaseClass` 基类的析构函数不是虚函数的时候，`delete sub` 对象的时候，只会释放 `BaseClass` 基类申请的资源，而不是释放 `SubClass` 派生类的资源。原因如下：

    基类指针指向了派生类对象，而基类中的析构函数是非virtual的，而虚构函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete的时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏，这是相当危险的：如果系统中有大量的派生类对象被这样创建和销毁，就会有内存不断的泄漏，久而久之，系统就会因为缺少内存而崩溃。

    当然，如果在派生类中没有动态申请有资源的时候，是不会造成内存泄漏的。而当派生类对象的析构函数中有内存需要回收，并且在编程过程中采用了基类指针指向派生类对象，如为了实现多态，并且通过基类指针将对象销毁，这时，就会因为基类的析构函数为非虚函数而不触发动态绑定，从而没有调用派生类的析构函数而导致内存泄漏。

    因此，为了防止这种情况下的内存泄漏的发生，最后将基类的析构函数写成virtual虚析构函数。

5. C++ 显示显式类型转换的好处和分类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* static_cast 完成相关类型之间的转换
* reinterpret_cast 处理互不相关类型之间的转换
* dynamic_cast 将基类类型转换为子类的类型，它涉及运行时检查
* const_cast 转换掉表达式的 const 性质

6. 如果避免多重继承中的在派生层次中出现多次
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

虚继承,
比如 istream 继承自 ios， ostream 也继承自 ios, 而 iostream 继承自 istream 和 ostream,
所以一个 iostream 对象可能会包含两个 ios 对象，所以要用到虚继承。

.. code-block:: c++

    class istream: public virtual ios { ... }
    class ostream: public virtual ios { ... }

7. 什么是模板的特化与偏特化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

8. vector, list, dqeue, map(红黑树), hashmap 的区别
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


9. 什么是 `auto_ptr`, 它有什么缺点，和 `shared_ptr`/`unique_ptr`/`weak_ptr` 有什么不一样？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


10. 为什么要用 extern c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

由于gcc和g++生成符号表的方式不同，导致在C++项目中如果使用gcc编译的C模块，会出现链接错误。因为链接器会去C模块的（.o）文件中查找，__Z3addii这样的符号。显然在C模块的目标文件(.o)中，不存在__Z3addii这样的符号，它有的只是_add。


通过extern "C"，告诉g++编译器，不要对这些函数进行Name mangling，按照C编译器的方式去生成符号表符号。这样在main.c的目标文件(.o)中，参数列表为两个int类型的add函数名称为_add。链接器可以正确找到util.o中的add函数（他们都是_add）。注意参数列表为两个double类型的add函数名称还是__Z3adddd。

11. 锁的类型和用法


12.


